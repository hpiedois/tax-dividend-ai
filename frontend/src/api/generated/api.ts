/* tslint:disable */
/* eslint-disable */
/**
 * Tax Dividend AI BFF API
 * Backend for Frontend API for Tax Dividend AI
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction, replaceWithSerializableTypeIfNeeded } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

export interface Dividend {
    'securityName': string;
    'isin'?: string;
    'grossAmount': number;
    'currency': string;
    'paymentDate'?: string;
    'withholdingTax'?: number;
    'reclaimableAmount'?: number;
    'sourceCountry'?: string;
    /**
     * Tracks which rate was applied (e.g. PFU, PROGRESSIVE, TREATY)
     */
    'appliedRateType'?: string;
}
export interface DividendCase {
    'id'?: string;
    'date'?: string;
    'security'?: string;
    'grossAmount'?: number;
    'reclaimedAmount'?: number;
    'status'?: DividendCaseStatusEnum;
}

export const DividendCaseStatusEnum = {
    Open: 'OPEN',
    Sent: 'SENT',
    Paid: 'PAID'
} as const;

export type DividendCaseStatusEnum = typeof DividendCaseStatusEnum[keyof typeof DividendCaseStatusEnum];

export interface DividendHistoryResponse {
    'data'?: Array<DividendCase>;
    'total'?: number;
    'page'?: number;
    'pageSize'?: number;
}
export interface DividendStatement {
    'dividends'?: Array<Dividend>;
    'metadata'?: DividendStatementMetadata;
}
export interface DividendStatementMetadata {
    'broker'?: string;
    'year'?: number;
}
export interface DividendStats {
    'totalReclaimed'?: number;
    'pendingAmount'?: number;
    'casesCount'?: number;
}
export interface FormDownloadUrlResponse {
    'url'?: string;
    'expiresAt'?: string;
}
export interface GenerateTaxFormsRequest {
    'dividendIds'?: Array<string>;
    'taxYear'?: number;
    'formType'?: GenerateTaxFormsRequestFormTypeEnum;
    'includeAttestation'?: boolean;
    'includeDividends'?: boolean;
}

export const GenerateTaxFormsRequestFormTypeEnum = {
    _5000: '5000',
    _5001: '5001',
    Bundle: 'BUNDLE'
} as const;

export type GenerateTaxFormsRequestFormTypeEnum = typeof GenerateTaxFormsRequestFormTypeEnum[keyof typeof GenerateTaxFormsRequestFormTypeEnum];

export interface GenerateTaxFormsResponse {
    'formUrl'?: string;
}
export interface GeneratedForm {
    'id'?: string;
    'formType'?: string;
    'taxYear'?: number;
    'fileName'?: string;
    'generatedAt'?: string;
}
export interface RegisterRequest {
    'email'?: string;
    'password'?: string;
    'fullName'?: string;
}
export interface UpdateDividendStatusRequest {
    'ids'?: Array<string>;
    'status'?: UpdateDividendStatusRequestStatusEnum;
}

export const UpdateDividendStatusRequestStatusEnum = {
    Open: 'OPEN',
    Sent: 'SENT',
    Paid: 'PAID'
} as const;

export type UpdateDividendStatusRequestStatusEnum = typeof UpdateDividendStatusRequestStatusEnum[keyof typeof UpdateDividendStatusRequestStatusEnum];


/**
 * AuthApi - axios parameter creator
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Register a new user
         * @param {RegisterRequest} [registerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register: async (registerRequest?: RegisterRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify email
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('verifyEmail', 'token', token)
            const localVarPath = `/auth/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Register a new user
         * @param {RegisterRequest} [registerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async register(registerRequest?: RegisterRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.register(registerRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.register']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Verify email
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyEmail(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyEmail(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.verifyEmail']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Register a new user
         * @param {RegisterRequest} [registerRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        register(registerRequest?: RegisterRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.register(registerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify email
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyEmail(token: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.verifyEmail(token, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Register a new user
     * @param {RegisterRequest} [registerRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public register(registerRequest?: RegisterRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).register(registerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify email
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public verifyEmail(token: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).verifyEmail(token, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DividendsApi - axios parameter creator
 */
export const DividendsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get dividend history
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDividendHistory: async (page?: number, pageSize?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dividends/history`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (pageSize !== undefined) {
                localVarQueryParameter['pageSize'] = pageSize;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get dividend statistics
         * @param {number} [taxYear] Optional tax year filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDividendStats: async (taxYear?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dividends/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (taxYear !== undefined) {
                localVarQueryParameter['taxYear'] = taxYear;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Parse a dividend statement (PDF/Image)
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parseDividendStatement: async (file?: File, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dividends/parse-statement`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (file !== undefined) { 
                localVarFormParams.append('file', file as any);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update status for multiple dividends
         * @param {UpdateDividendStatusRequest} updateDividendStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDividendStatus: async (updateDividendStatusRequest: UpdateDividendStatusRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateDividendStatusRequest' is not null or undefined
            assertParamExists('updateDividendStatus', 'updateDividendStatusRequest', updateDividendStatusRequest)
            const localVarPath = `/dividends/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateDividendStatusRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DividendsApi - functional programming interface
 */
export const DividendsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DividendsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get dividend history
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDividendHistory(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DividendHistoryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDividendHistory(page, pageSize, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DividendsApi.getDividendHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get dividend statistics
         * @param {number} [taxYear] Optional tax year filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDividendStats(taxYear?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DividendStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDividendStats(taxYear, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DividendsApi.getDividendStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Parse a dividend statement (PDF/Image)
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parseDividendStatement(file?: File, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DividendStatement>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parseDividendStatement(file, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DividendsApi.parseDividendStatement']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update status for multiple dividends
         * @param {UpdateDividendStatusRequest} updateDividendStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateDividendStatus(updateDividendStatusRequest: UpdateDividendStatusRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateDividendStatus(updateDividendStatusRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DividendsApi.updateDividendStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DividendsApi - factory interface
 */
export const DividendsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DividendsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get dividend history
         * @param {number} [page] 
         * @param {number} [pageSize] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDividendHistory(page?: number, pageSize?: number, options?: RawAxiosRequestConfig): AxiosPromise<DividendHistoryResponse> {
            return localVarFp.getDividendHistory(page, pageSize, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get dividend statistics
         * @param {number} [taxYear] Optional tax year filter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDividendStats(taxYear?: number, options?: RawAxiosRequestConfig): AxiosPromise<DividendStats> {
            return localVarFp.getDividendStats(taxYear, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Parse a dividend statement (PDF/Image)
         * @param {File} [file] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parseDividendStatement(file?: File, options?: RawAxiosRequestConfig): AxiosPromise<DividendStatement> {
            return localVarFp.parseDividendStatement(file, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update status for multiple dividends
         * @param {UpdateDividendStatusRequest} updateDividendStatusRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDividendStatus(updateDividendStatusRequest: UpdateDividendStatusRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.updateDividendStatus(updateDividendStatusRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DividendsApi - object-oriented interface
 */
export class DividendsApi extends BaseAPI {
    /**
     * 
     * @summary Get dividend history
     * @param {number} [page] 
     * @param {number} [pageSize] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDividendHistory(page?: number, pageSize?: number, options?: RawAxiosRequestConfig) {
        return DividendsApiFp(this.configuration).getDividendHistory(page, pageSize, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get dividend statistics
     * @param {number} [taxYear] Optional tax year filter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getDividendStats(taxYear?: number, options?: RawAxiosRequestConfig) {
        return DividendsApiFp(this.configuration).getDividendStats(taxYear, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Parse a dividend statement (PDF/Image)
     * @param {File} [file] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public parseDividendStatement(file?: File, options?: RawAxiosRequestConfig) {
        return DividendsApiFp(this.configuration).parseDividendStatement(file, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update status for multiple dividends
     * @param {UpdateDividendStatusRequest} updateDividendStatusRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public updateDividendStatus(updateDividendStatusRequest: UpdateDividendStatusRequest, options?: RawAxiosRequestConfig) {
        return DividendsApiFp(this.configuration).updateDividendStatus(updateDividendStatusRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FormsApi - axios parameter creator
 */
export const FormsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete form
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteForm: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteForm', 'id', id)
            const localVarPath = `/forms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Download form
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadForm: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('downloadForm', 'id', id)
            const localVarPath = `/forms/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/pdf,application/zip';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Generate tax forms
         * @param {GenerateTaxFormsRequest} [generateTaxFormsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateTaxForms: async (generateTaxFormsRequest?: GenerateTaxFormsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/forms/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Content-Type'] = 'application/json';
            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateTaxFormsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get form metadata
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForm: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getForm', 'id', id)
            const localVarPath = `/forms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get pre-signed download URL for form
         * @param {string} id 
         * @param {number} [expiresIn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFormDownloadUrl: async (id: string, expiresIn?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFormDownloadUrl', 'id', id)
            const localVarPath = `/forms/{id}/download-url`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (expiresIn !== undefined) {
                localVarQueryParameter['expiresIn'] = expiresIn;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary List user\'s forms
         * @param {number} [taxYear] 
         * @param {string} [formType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForms: async (taxYear?: number, formType?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/forms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (taxYear !== undefined) {
                localVarQueryParameter['taxYear'] = taxYear;
            }

            if (formType !== undefined) {
                localVarQueryParameter['formType'] = formType;
            }

            localVarHeaderParameter['Accept'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FormsApi - functional programming interface
 */
export const FormsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FormsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete form
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteForm(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteForm(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormsApi.deleteForm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Download form
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async downloadForm(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.downloadForm(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormsApi.downloadForm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Generate tax forms
         * @param {GenerateTaxFormsRequest} [generateTaxFormsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generateTaxForms(generateTaxFormsRequest?: GenerateTaxFormsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateTaxFormsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generateTaxForms(generateTaxFormsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormsApi.generateTaxForms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get form metadata
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getForm(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GeneratedForm>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getForm(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormsApi.getForm']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get pre-signed download URL for form
         * @param {string} id 
         * @param {number} [expiresIn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFormDownloadUrl(id: string, expiresIn?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FormDownloadUrlResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFormDownloadUrl(id, expiresIn, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormsApi.getFormDownloadUrl']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary List user\'s forms
         * @param {number} [taxYear] 
         * @param {string} [formType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listForms(taxYear?: number, formType?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GeneratedForm>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listForms(taxYear, formType, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FormsApi.listForms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FormsApi - factory interface
 */
export const FormsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FormsApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete form
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteForm(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Download form
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadForm(id: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.downloadForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Generate tax forms
         * @param {GenerateTaxFormsRequest} [generateTaxFormsRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generateTaxForms(generateTaxFormsRequest?: GenerateTaxFormsRequest, options?: RawAxiosRequestConfig): AxiosPromise<GenerateTaxFormsResponse> {
            return localVarFp.generateTaxForms(generateTaxFormsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get form metadata
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getForm(id: string, options?: RawAxiosRequestConfig): AxiosPromise<GeneratedForm> {
            return localVarFp.getForm(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get pre-signed download URL for form
         * @param {string} id 
         * @param {number} [expiresIn] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFormDownloadUrl(id: string, expiresIn?: number, options?: RawAxiosRequestConfig): AxiosPromise<FormDownloadUrlResponse> {
            return localVarFp.getFormDownloadUrl(id, expiresIn, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary List user\'s forms
         * @param {number} [taxYear] 
         * @param {string} [formType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listForms(taxYear?: number, formType?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<GeneratedForm>> {
            return localVarFp.listForms(taxYear, formType, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FormsApi - object-oriented interface
 */
export class FormsApi extends BaseAPI {
    /**
     * 
     * @summary Delete form
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public deleteForm(id: string, options?: RawAxiosRequestConfig) {
        return FormsApiFp(this.configuration).deleteForm(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Download form
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public downloadForm(id: string, options?: RawAxiosRequestConfig) {
        return FormsApiFp(this.configuration).downloadForm(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Generate tax forms
     * @param {GenerateTaxFormsRequest} [generateTaxFormsRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public generateTaxForms(generateTaxFormsRequest?: GenerateTaxFormsRequest, options?: RawAxiosRequestConfig) {
        return FormsApiFp(this.configuration).generateTaxForms(generateTaxFormsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get form metadata
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getForm(id: string, options?: RawAxiosRequestConfig) {
        return FormsApiFp(this.configuration).getForm(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get pre-signed download URL for form
     * @param {string} id 
     * @param {number} [expiresIn] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public getFormDownloadUrl(id: string, expiresIn?: number, options?: RawAxiosRequestConfig) {
        return FormsApiFp(this.configuration).getFormDownloadUrl(id, expiresIn, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary List user\'s forms
     * @param {number} [taxYear] 
     * @param {string} [formType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    public listForms(taxYear?: number, formType?: string, options?: RawAxiosRequestConfig) {
        return FormsApiFp(this.configuration).listForms(taxYear, formType, options).then((request) => request(this.axios, this.basePath));
    }
}



